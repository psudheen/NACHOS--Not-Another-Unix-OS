                                                                    
			******************************************************************************                                             
			Title: Writeup for Project 4- Distributed Carls Jr Simulation, fall 2010
			******************************************************************************
Date:12/31/2010	  		

Group Number :44 	Name			Email ID	        Student ID
			Pramod K Sudheendra, 	psudheen@usc.edu	6592406458
			Venkat Paritala		paritala@usc.edu	2891653047					
			Abhindandan prativadi	prativad@usc.edu	3512718295				 	
...............................................................................................................................................................................................................................................................................

I. Requirements:
----------------
In project 4 the main goal is to create a distributed system for allowing user programs which are spread across multiple nachos insatnces to participate in a single Carls Jr Simulation. In this scenario, a user program does not know where any other user program is executing.

For acheieving this, we create a networking thread that will handle the networking tasks of each userprogram separately. So essentially for each userprogram we need two threads, One thread will be the Carls Jr simulation entity (a Nachos user program) and the 
other thread will be listening for messages from other group members (a Nachos kernel thread). 

So every time a userprogram thread wants to make a system call it will send a message to its corresponding networking thread(which acts as a server to that userprogram thread). This is transparent to user program.
Each request from the user program is sent to all other network threads.

For this to be possible the network threads should be knowing the presence(ie client id and mailbox number) of other networking threads, so
initially we make all the networking threads register with a server, we call this a "group server". 

The user programs are made to wait on network threads at the beginning of the simulation for group registration to complete, for this we create a new system call called the startsimulation. The network threads send there details to the group server and once group sever receives the expected number 
of registrations, it sents out information about client id and mailbox number of all networking threads to all the networking threads.
Then group server shuts down.

We have to ensure that the total ordering occurs for messsages exchanged between the threads so we assign timestamp with each message and all networking 
threads execute in the same manner(ie lowest timestamp message is executed first).

EXTRA CREDIT:  The main goal is to test the ability of the kernel to handle the loss of packets
                We have to make sure that
								->Any message received in order is to be printed-out for a particular machine-ID/mailbox-number combination. 
								->Each kernel function should  print out messages in increasing sequence number order for each other kernel function.
								
                To test this, we have to run kernel functions, and use -l command, and see whether we get all the packets we expected.
								We create kernel functions, we make them send packets to all the known kernelfunctions ruuning on the other instances of nachos, then the kernel functions
								go on recieve.
						    They print only in order messages and send an ack to the corresponding machine id. (We ignore out of order message).If an ack was previously sent for an out of order message it just recieved, it will resend the ack, else it simply ignores the message.
						    To handle the loss packets, we add all the sent messages into a queue, the messages in the queue are resend once the timer expires, so for this we need a timer function.
               								



----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

II. Assumptions:
------------------

1)Memory model is assumed to be that of project 2 ie multiprogramming with large physical memory
2)The machine id is always a single digit, this is done to accomaodate message limit of 40 bytes
3) The maximum number of locks, condition variables is assumed to be 500
4) The maximum number of monitor variables that can be created are 1000
5) UserStack space is assumed to be large to accomdate huge data exchange over network
6) Network relability is assummed to be 100% for Carl Jr simulation.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------


III. Design:
------------
Project 4:


Group Server Registration:
---------------------------

In main.cc a function called GroupServer is included, which performs the following tasks:

We run a group server in a seperate instance of nachos, the total number of networking threads are inputed by the user, each networking thread goes on recieve mode on the group server
once the number of expected networking threads are registered with the group server, it sends out the number of threads(so that the networking threads receive the messages in a loop for that many times) and details(client id and mailboxnumber) of each networking thread to all the networking threads.
After sending all the details the Group server shuts down.

All networking threads store these details, which will be used later to send messages.
Once the networking thread receives all the messages, it sends a message to its userprogram indicating that it can start its execution.
This completes the group registration process.

NetworkingThread Details
-------------------------
In thread.h
The thread class is modified, we associate a unique number with every thread, this is the mailbox number of that thread.
To access this value we have included two functions in the thread class getMailboxNo(),setMailboxNo() which return or set a given value respectively.

In Exception.cc 
The exec system call is modified, when ever a user program thread is created by calling Exec, we create its corresponding networking thread.
We maintain a global counter called nextmailboxno which is incremented upon creation of new thread,since the user program thread and its corresponding network thread are forked together, they have consecutive mailbox numbers.
So a networking thread decides whether the message is from userprogram just by subtracting 1 from its mailbox number.



*************************************TOTAL ORDER MESSAGE PASSING ALGORITHM********************************************************
The following are the steps performed by each networking thread to achieve total ordering of events

1.Recieve a message
2.Extract timestamp and mebers ID
3.Update last timestamp in my table for that member
4. Insert the message into the my message queue in the time stamp order
5. Extract the earliest time satmp value from my table
6.Process any message in timestamp order, with a timestamp less than or equal to value from step 4

The networking thread is always in the receive mode, it can either get messages from its own userprogram thread or from other networking thread including itself.
There are two types of messages possible, one being the update message and the other is action message.
If it gets a message from its userprogram thread( this is called action message) it appends its time stamp to that message and forwards it to every networking thread including itself.
If it gets a message from networking threads it will check whether it is a action message or an update message, if it is an update message it simply updates its time,
if its a action message, it first it sends out its time update message to all netwoking threads including itself and then processes the action message according to the total ordering policy.
If this action message is from its own userprogram thread then it will return a value depending on the request inside the message,otherwise if this message is from other networking thread it just
updates its tables(ie Lock,Cv,Mv etc) depending on the type of action specified in the message.




When a user program request a system call, the exception handler will call aprropriate system call, here the validations such as

// Is the size of the name passed is valid
//Is the virtual address valid
// Is the lock, cv or mv in the range of possible values
If any of these validations fail, print approriate error message and return
Else it will pack the request type and the received name of lock, cv or mv in a buffer and sends it to its networking thread
Now it enters the receive mode, so here every networking thread acts as a server for its userprogram thread

Each networking thread has its own tables(ie data structures for Locks,Cv's and MV's) which are local to that netwoking thread,which are updated in the same manner by all the networking threads

So after extracting the earliest time satmp message we call a function called Decode message, this fuction extracts the clientid,machineID and the type of request, the following are the type of requests which a userprogram may request:

1. SC_CreateLock: In this case we call serverCreatelock function:
 
   // It checks whether the lock alredy exists  
   // If it does then it will return the index of the lock
   // If it doesnt then, it will check if the maximum possible number of locks has alredy been reached
   // If yes then it prints an error message
   // Else it will create a new lock(ie increment the lock counter value) and return that value
      
2. SC_Acquire: In this case we call ServerAcquireLock function: 
    
    // Check whether the lock id being requested is within the possible range of locks
    // If no return by printing an approriate error message
    // It checks whether the requesting thread is already the lock owner
    // If yes then it packs a message called failure and sends it to userprogam  thread
    // Next it checks the status of the requested lock,if it is free it sends a success message to its userprogram thread
    // If it is busy then it appends this thread into the waiting queue of the lock

3. SC_Release: In this case we call ServerReleaseLock function:
   
    //Check whether the lock id is within the possible range of locks
    //If no return by printing an approriate error message
    // Check whether the current thread is the owner if no then print an error message and send it to userprogram.
    // If yes, then send a success message, if the waiting q for that lock is not empty remove one thread from the list and make it the owner of the lock, set its status as busy and return
    // If the waiting q list is empty then simply set the satus of the lock as free and its owner as -1 and reuturn 


4. SC_DestroyLock: In this case we call ServerDestroyLock function:
  
    //Check whether the lock id is within the possible range of locks
    //If no return by printing an approriate error message
    // If the usage counter is 1 and the satus is free, set usage counter to zero and satus =-1 and make ownner as null, this implies the lock is succesfully destroyed, send a Success message to userprogram thread
    // Else print an error message saying its a busy lock and send a failure message to userprogram thread

5. SC_CreateCondition: In this case we call ServerCreateConditionfunction:
   
   // It checks whether the cv name  alredy exists  
   // If it does then it will return the index of the cv
   // If it doesnt then, it will check if the maximum possible number of cvs has alredy been reached
   // If yes then it prints an error message
   // Else it will create a new cv(ie increment the cv counter value) and return that integer value

6.   SC_DestroyCondition :In this case we call ServerDestroyCondition function:
   
    
    //Check whether the cv id is within the possible range of cv's
    //If no return by printing an approriate error message
    // If the usage counter is 1 and the satus is free, set usage counter to zero, status as void, owner as -1 ans name of cv as "", this implies successfull deletion of Cv, print approriates ucces message and retun the same
    // Else print an error message indiacting the cv is busy and return the same.

7.   SC_Wait: In this case we call ServerWait function:
     
      //Check whether the lock id is within the possible range of locks
      //If no return by printing an approriate error message
      //Check whether the cv id is within the possible range of cv's
      //If no return by printing an approriate error message
      // Check if the requesting thread is the owner of the lock, if no print error message and return the same.
      //Check whether the waiting lock matches the save lock, if no print error message and return the same
      //If all checks are passed, append the servercvwaitq with the clientid,threadid and lock id.
      // Check if the queue for that lockid is empty, if yes then make the locksatus free, else remove a thread from the queue and make that thread as the lock owner and return

8.    SC_Signal: In this case we call ServerSignal function:

      //Check whether the lock id is within the possible range of locks
      //If no return by printing an approriate error message
      //Check whether the cv id is within the possible range of cv's
      //If no return by printing an approriate error message
      // Check if input condition lock matches the saved lock, if no print error and return the same
      // If it matches, check if ServerCVWaitQ is empty, if yes send a failure message, if no then remove one thread from condition wait queue
      // Check if the lock status is free if yes then make this woken up thread as its owner, else append it ti the lock wait queue

9.    SC_Broadcast:In this case we call ServerBroadcast function:

      //The validations are same as that as signal
      // Instead of removing a single thread form the queue, broadcast signals untill the queue is empty

10.   SC_CreateMV: In this case we call ServerCreateMV function:
      
    // It checks whether the MV alredy exists  
   // If it does then it will return the index of the lock
   // If it doesnt then, it will check if the maximum possible number of MV's has alredy been reached
   // If yes then it prints an error message
   // Else it will create a new MV(ie increment the lock counter value) and return that value

11.   SC_DestroyMV:In this case we call ServerDestroyMV function:
          
     //Check whether the MV id is within the possible range of MV's
    //If no return by printing an approriate error message
    // Check if the status of the MV is void, if yes print an approriate error message and return the same
    // If the usage counter is 1, then set it to zero,owner,mvthreadid,satus to -1, and name as"", this inidactes the MV is succefully deleted, send a success message

12.  SC_SetMV: In this case we call ServerSetMV function:


    //Check whether the MVid or the mv value has exceeded the maximum possible mvid's or value, if either of this is true print a error message and return the same
    //If the Mv status is not void then set the mvvalue to the required value and send a success message

13    SC_GetMV: In this case we call ServerGetMVfunction: 
     
    //Check whether the MVid or the mv value has exceeded the maximum possible mvid's or value, if either of this is true print a error message and return the same
    // If the mvstatus is not void then return the value of the mv.
      


      In all the above cases, before calling the return the respond to client fucntion is called- This function checks, if the action message was originally sent by its own userprogram thread, just by checking current networking thread's mailbox number minus 1
      if yes, then it will send the return integer value/SUCCESS/FAILURE message  to its user program, else it does nothing assuming that all the tables were updated in decode message, then the contorl is returned to the decode message which in turns returns the control to 
      networking thread, which enters recieving mode again.


Extra Credit:

In post.cc 
There are two types of messages involed, one is acknowledgement amd the other is the actual message.
Before the actual send occurs, we unpack every message and check whether its an acknowledgement or a data message, if it is data message we add it into a global queue of sent messages, else we dont add it.
This queue is created in system.cc 

In nettest.cc
The kernel function is written here, each instance of nachos runs the same code, and is differentiated from other by its machine id.
At the begining of the execution we create certain delay, so as to ensure the other instances are running as well.
The first task of kernelfunc is it sends out 5 messages to each of the other kernel funcs, since we know before hand which all instances are running, we hard code the outpkthdr filed in a loop.
The format of the message is <tmsg;(number)>, here tmsg inidicates its a true message, so that we can differentiate it with the ack message, number is ranging from 0-4,
this is the actual message that we are sending and is printed out on the each terminal. It servers both as the data as well as sequence number.
After sending out the messages the kernel func enters an while(1) looop and continuosly goes on receive.

Receive logic of kernelfunc

It can either receive a ack message for a message which it sent out initilally or it can receive data message from other kernelfn's 

-> unpack the message and check whether it is an ack message, if yes remove it from the global resend queue, this is done by comparing the msgnumnber and the clientid from which it recieved, with msgnum of messages in the queue and client number, to which it initially had sent to
-> If it is not an acknowledgement, I got a message from other kernel fn, if it is in order i need to print it out, if it is out of order, but i have akcked it alreday, resend ack.   
   since we know the messages to be from 0-4, we initally set a flag to zero and when we get a message from that client which macthes my current flag value, then we print it out
    Also i will send an acknowledgement to the corresponding client, indicating that i have received the message, i keep a note of acknowledgemets i sent.
-> If it is out of order message, i check whether it was acknowledged already, if yes then it implies the ack was lost so i resned the ack, and ignore the message.
   If it was not acknowledged earlier i simply ignore the message. The above steps are doen for each cleint id i am expecting messages from

	 
In system.cc
->I create a new timer object called timersend which is created only if the command is -l, this timer object calls a function called resendTimerfn periodically
-> The resendTimerfn forks a new thread called resendMsgfn, every time the difference in current time and the last forked time exceeds the threshold value(time)
    This function removes all the messages from the global resend queue one by one, unpack the data and get the destination clinet id and resends it, these messages are copied into a temp list and are
		back into the global resned queue. Since these are messages, to avoid them being added to the global queue when resndtimerfn sends them, we make the outpkthdrfrom as 51, in post.cc
		we check for 51 if yes we make outpkthdr as currentkernelfn clientid and send without adding it to the queue.
		
 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


IV. Implementation
-------------------




	------------------------------------------------------------------------------------------------------------------------------------------------------------
	+ Files Modified
	/userprog/exception.cc
	/machine/machine.h
	/threads/system.cc
	/threads/system.h
	/userprog/addrspace.h
	/userprog/addrspace.cc
	/network/nettest.cc
	/threads/main.cc
     /threads/thread.h
	/threads/syscall.h
     /test/start.s
     /network/post.cc
	 /test/sort.c
	 /test/testfiles.c
	 
        


	------------------------------------------------------------------------------------------------------------------------------------------------------------	

	+ Files added
	
All below files in ../test directory
  OrdT1.c
	cok.c
	cok1.c
	cust2 
	mg2.c 
	n0.c
	n2.c
	n4.c 
	waitr1.c
  cust.c  
	cust2.c                         
OrdT.c 
         OrdT2.c 
				 cok01.c  
				 cok2.c    
				 mg1.c     
				 mgwt.c
				 n1.c  
				 n3.c
				 waiter.c
				 waitr2.c
       cust1.c 
			 halt.c                   

	

	

	------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	
	
			
	+ Data Structures modified, and the file they were added to.
	------------------------------------------------------------------------ In Addrspace.h
	ALL the entities are restored to project 2 entities

	------------------------------------------------------------------------------------------------------------------------------------------------------------ In Exception.cc

        typedef struct mailBox_t
{
int MailBoxNo;
	unsigned long int TimeStamp;
};
         
        
typedef struct LastTimeStampTable_t
{
	unsigned long int TimeStamp;
};

        typedef struct SvrLockData_t
{
int IsOkToDestroy;
	int UsageCntr;
	char* LockName;
	int LockOwner;
	int LockThreadID;
int Status;
};

        typedef struct SvrCVData_t
{
int IsOkToDestroy;
int UsageCntr;
char* CVName;
int CVOwner;
int CVThreadID;
int Status;
};

        typedef struct SvrMVData_t
{
int IsOkToDestroy;
int UsageCntr;
char* MVName;
int MVValue;
int MVOwner;
int MVThreadID;
int Status;
};


        ------------------------------------------------------------------------------------------------------------------------------------------------------------- In thread.h

	class Thread {
  private:
    // NOTE: DO NOT CHANGE the order of these first two members.
    // THEY MUST be in this position for SWITCH to work.
    int* stackTop;			 // the current stack pointer
    int machineState[MachineStateSize];  // all registers except for stackTop

  public:
    Thread(char* debugName);		// initialize a Thread 
    ~Thread(); 				// deallocate a Thread
					// NOTE -- thread being deleted
					// must not be running when delete 
					// is called

    // basic thread operations

    void Fork(VoidFunctionPtr func, int arg); 	// Make thread run (*func)(arg)
    void Yield();  				// Relinquish the CPU if any 
						// other thread is runnable
    void Sleep();  				// Put the thread to sleep and 
						// relinquish the processor
    void Finish();  				// The thread is done executing
    
    void CheckOverflow();   			// Check if thread has 
						// overflowed its stack
    void setStatus(ThreadStatus st) { status = st; }
    char* getName() { return (name); }
    void Print() { printf("%s, ", name); }		
    void setMailboxNo(int MailboxNum) { mailboxNo = MailboxNum; } 
    int getMailboxNO() { return mailboxNo; }

  private:
    // some of the private data for this class is listed above
    
    int* stack; 	 		// Bottom of the stack 
					// NULL if this is the main thread
					// (If NULL, don't deallocate stack)
    ThreadStatus status;		// ready, running or blocked
    char* name;

    void StackAllocate(VoidFunctionPtr func, int arg);
    					// Allocate a stack for thread.
					// Used internally by Fork()
		int mailboxNo;
	

	functions added 
	------------------------------------------------------------------------ In Exception.cc
        unsigned long int getTheTimeStamp();
	bool isHeldByCurrentThread(int LockID,int ClientID,int ThreadID,SvrLockData_t *SvrLocks);
        void RespondToClient(char *SrvBuffer, int ClientID, int ThreadID,int ntThreadMailboxID);
        void initialize(SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ,int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter);
        void DecodeMsg(char *buffer, SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerCreateLock(int ClientID, int ThreadID,char *LockName, SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerAcquireLock(int ClientID, int ThreadID,int LockID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerReleaseLock(int ClientID, int ThreadID,int LockID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerDestroyLock(int ClientID, int ThreadID,int LockID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerCreateCondition(int ClientID, int ThreadID,char *CvName,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerWait(int ClientID, int ThreadID,int LockID,int CvID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerDestroyCondition(int ClientID, int ThreadID,int CvID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerSignal(int ClientID, int ThreadID,int LockID,int CvID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerBroadcast(int ClientID, int ThreadID,int LockID,int CvID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerCreateMV(int ClientID, int ThreadID,char *MVName,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerDestroyMV(int ClientID, int ThreadID,int MVID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerSetMV(int ClientID, int ThreadID,int MVID, int MVValue,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);
        int ServerGetMV(int ClientID, int ThreadID,int MVID,SvrLockData_t *SvrLocks, SvrCVData_t *SvrCV,SvrMVData_t  *SvrMV, int *WaitingLockInCV, List **ServerCVWaitQ, List **SvrLockWaitQ, int *SrvLockCounter, int *SrvCVCounter, int *SrvMVCounter,int ntThreadMailboxID);         
        void StartSimulation();
 
	------------------------------------------------------------------------------------- In system.cc
	void resendMsgfn();
	void resendTimerfn(int dummy);
	
	--------------------------------------------------------------------------------------In nettest.cc
	void KernelFn();
	------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	

	functions modified
	------------------------------------------------------------------------ In Exception.cc
	void ExceptionHandler(ExceptionType which);
	int CreateLock_Syscall(unsigned int vaddr, int len);
	void DestroyLock_Syscall(int LockPos);
	void AcquireLock_Syscall(int LockPos);
	void ReleaseLock_Syscall(int LockPos);
	int CreateCondition_Syscall(unsigned int vaddr, int len);
	void DestroyCondition_Syscall(int ConditionPos);
	void Wait_Syscall(int ConditionPos,int LockPos);
	void Signal_Syscall(int ConditionPos,int LockPos);
	void Broadcast_Syscall(int ConditionPos,int LockPos);
	void Fork_Syscall( unsigned int vaddr);
	
	
		
	------------------------------------------------------------------------------------------------------------------------------------------------------------	
	
	

	
	




----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

V.Testing
-------------

	------------------------------------------------------------------------------------------------------------------------------------------------------------
	+ How to test

	Compile the files in network, test directory.
	
	Project4:
	
	Test case 1: DISTRIBUTED CARL'S JUNIOR SINGLE INSTANCE
	   
		             Here we have implemented the entire working of carls junior. We are starting with an empty inventory level and empty raw material.
								 Hence this simulation involves the all the 5 entities - Manager,Cook,waiter,ordertaker,customer
								 total running entities: 20
								 
								 Customers: 10
								 OrderTakers: 3
								 Waiters:2
								 Manager: 1
								 Cook: 4
								 Eatin Customers:5
								 ToGo Customers:5
								 
								 
								 Testing Steps:
								 
								 -> Open 2 Terminals
								 
								 Terminal 1: nachos -gs 20 -m 0 -d -q
								 This runs group server registration
								 
								 Terminal 2:nachos -m 1 -x ../test/n0
								 This runs carls jr simulation
								 
								 Expected OutPut: ALL the customers leave the restaurant once they get their food
								 
								 Eatin Customers:5
								 ToGo Customers:5
								 
								 Customer ids that choose to eatin the restaurant: 0, 1 , 2 , 3  
								 Customer ids that choose to go the food: 4, 5, 6 ,7 , 8 ,9  
								 
	Test Case 2: DISTRIBUTED CARL JR FOR MULTIPLE INSTANCE

				In this we are running reduced Carl jr simulation
				 Customers: 2
				 OrderTakers: 1
				 Waiters:1
				 Manager: 1
				 Cook: 1
				
				 Testing Steps:
								 
								 -> Open 3 Terminals
								 
								 Terminal 1: nachos -gs 6 -m 0 -d -q
								 This runs group server registration
								 
								 Terminal 2:nachos -m 1 -x ../test/n3
								 This runs carls jr simulation part
	
								Terminal 3: nachos -m 2 -x ../test/n4
								This runs the other part of carl jr
								
								Expected OutPut: ALL the customers leave the restaurant once they get their food
								 
							
							
								
								NOTE:
								Because there might be nachos network problem in writing to the SOCKET file, in case it doesnt respond PLEASE end and restart the simultion.


	Test Case 3: DISTRIBUTED CARL JR FOR MULTIPLE INSTANCE

				In this we are running reduced Carl jr simulation
				 Customers: 4
				 OrderTakers: 2
				 Waiters:1
				 Manager: 1
				 Cook: 1
				
				 Testing Steps:
								 
								 -> Open 3 Terminals
								 
								 Terminal 1: nachos -gs 9 -m 0 -d -q
								 This runs group server registration
								 
								 Terminal 2:nachos -m 1 -x ../test/n1
								 This runs carls jr simulation part
	
								Terminal 3: nachos -m 2 -x ../test/n2
								This runs the other part of carl jr
								
								Expected OutPut: ALL the customers leave the restaurant once they get their food
								 
							
								
								NOTE:
								Because there might be nachos network problem in writing to the SOCKET file,so in case nachos doesnt respond PLEASE end and restart the simultion.



								
      
	Extra Credit-----------------------------------------------------------------------------

   Test case 1:  5 instances of nachos for lost packet simulation for various -l values:
	 
	  Open 5 terminals, give the commands as follows in terminals 1 to 5 respectively
		nachos -m 0 -l 0.7    
		nachos -m 1 -l 0.7
		nachos -m 2 -l 0.7
		nachos -m 3 -l 0.7
		nachos -m 4 -l 0.7
 
    After entering the above commands in all the terminals, please press a number greater than 2 say 5, in all the terminals.
	  Please enter the number within 8 seconds, if you get an error saying postoffice send failed other instance should be running, please
		type in the commands again. 
		
		
		
		Excpected output:
		The ouput in each of the windows is similar to the ones below:
		
		Terminal 0:
		Please enter the number of nachos instances required: 
		Kernel function has started
		Recieved MSg 0 from 2 client
		Recieved MSg 0 from 3 client
		Recieved MSg 1 from 3 client
		Recieved MSg 0 from 1 client
		Recieved MSg 1 from 1 client
		Recieved MSg 2 from 3 client
		Recieved MSg 3 from 3 client
		Recieved MSg 0 from 4 client
		Recieved MSg 1 from 4 client
		Recieved MSg 2 from 1 client
		Recieved MSg 3 from 1 client
		Recieved MSg 2 from 4 client
		Recieved MSg 3 from 4 client
		Recieved MSg 1 from 2 client
		Recieved MSg 2 from 2 client
		Recieved MSg 3 from 2 client
		Recieved MSg 4 from 3 client
		Recieved MSg 4 from 1 client
		Recieved MSg 4 from 4 client
		Recieved MSg 4 from 2 client

		Terminal 1:
		Please enter the number of nachos instances required: 
		Kernel function has started
		Recieved MSg 0 from 0 client
		Recieved MSg 1 from 0 client
		Recieved MSg 0 from 2 client
		Recieved MSg 1 from 2 client
		Recieved MSg 2 from 0 client
		Recieved MSg 3 from 0 client
		Recieved MSg 0 from 3 client
		Recieved MSg 1 from 3 client
		Recieved MSg 2 from 3 client
		Recieved MSg 2 from 2 client
		Recieved MSg 3 from 3 client
		Recieved MSg 4 from 3 client
		Recieved MSg 0 from 4 client
		Recieved MSg 1 from 4 client
		Recieved MSg 2 from 4 client
		Recieved MSg 3 from 4 client
		Recieved MSg 4 from 4 client
		Recieved MSg 3 from 2 client
		Recieved MSg 4 from 2 client
		Recieved MSg 4 from 0 client

		Terminal 2:
		
		Please enter the number of nachos instances required: 
		Kernel function has started
		Recieved MSg 0 from 0 client
		Recieved MSg 1 from 0 client
		Recieved MSg 2 from 0 client
		Recieved MSg 3 from 0 client
		Recieved MSg 4 from 0 client
		Recieved MSg 0 from 1 client
		Recieved MSg 1 from 1 client
		Recieved MSg 2 from 1 client
		Recieved MSg 3 from 1 client
		Recieved MSg 4 from 1 client
		Recieved MSg 0 from 3 client
		Recieved MSg 1 from 3 client
		Recieved MSg 0 from 4 client
		Recieved MSg 1 from 4 client
		Recieved MSg 2 from 3 client
		Recieved MSg 3 from 3 client
		Recieved MSg 4 from 3 client
		Recieved MSg 2 from 4 client
		Recieved MSg 3 from 4 client
		Recieved MSg 4 from 4 client

		
		Terminal 3:
		Please enter the number of nachos instances required: 
		Kernel function has started
		Recieved MSg 0 from 2 client
		Recieved MSg 1 from 2 client
		Recieved MSg 2 from 2 client
		Recieved MSg 3 from 2 client
		Recieved MSg 0 from 1 client
		Recieved MSg 1 from 1 client
		Recieved MSg 2 from 1 client
		Recieved MSg 3 from 1 client
		Recieved MSg 4 from 1 client
		Recieved MSg 4 from 2 client
		Recieved MSg 0 from 0 client
		Recieved MSg 0 from 4 client
		Recieved MSg 1 from 0 client
		Recieved MSg 1 from 4 client
		Recieved MSg 2 from 0 client
		Recieved MSg 3 from 0 client
		Recieved MSg 2 from 4 client
		Recieved MSg 4 from 0 client
		Recieved MSg 3 from 4 client
		Recieved MSg 4 from 4 client

		
		Terminal 4:
		Please enter the number of nachos instances required: 
		Kernel function has started
		Recieved MSg 0 from 0 client
		Recieved MSg 1 from 0 client
		Recieved MSg 2 from 0 client
		Recieved MSg 0 from 2 client
		Recieved MSg 1 from 2 client
		Recieved MSg 2 from 2 client
		Recieved MSg 3 from 2 client
		Recieved MSg 3 from 0 client
		Recieved MSg 0 from 3 client
		Recieved MSg 1 from 3 client
		Recieved MSg 4 from 2 client
		Recieved MSg 4 from 0 client
		Recieved MSg 0 from 1 client
		Recieved MSg 1 from 1 client
		Recieved MSg 2 from 1 client
		Recieved MSg 3 from 1 client
		Recieved MSg 4 from 1 client
		Recieved MSg 2 from 3 client
		Recieved MSg 3 from 3 client
		Recieved MSg 4 from 3 client
		
		
		Test case 2:  2 instances of nachos for lost packet simulation for -l values as low as 0.1 :
		
		 nachos -m 0 -l 0.1 
		 nachos -m 1 -l 0.1
		 
		 Type in the above commnands and enter a number less than 2 say 1, in both the terminals withing 6secs to start the simulation
		 
		 Excpected output:
		 The ouput you get after execution is similar to the one below
		 
		 Terminal 0:
		Please enter the number of nachos instances required: 
		Kernel function has started
		Recieved MSg 0 from 1 client
		Recieved MSg 1 from 1 client
		Recieved MSg 2 from 1 client
		Recieved MSg 3 from 1 client
		Recieved MSg 4 from 1 client
		 
		 Terminal 1:
		Please enter the number of nachos instances required: 
		Kernel function has started
		Recieved MSg 0 from 0 client
		Recieved MSg 1 from 0 client
		Recieved MSg 2 from 0 client
		Recieved MSg 3 from 0 client
		Recieved MSg 4 from 0 client
  	 
	
	------------------------------------------------------------------------------------------------------------------------------------------------------------	
	
	
	
		 
	------------------------------------------------------------------------------------------------------------------------------------------------------------	
	

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
VII. Miscellaneous

Carls's junior simulation shows a lot of debug messages(we ran out of time and hence we could not remove it) along with expected output, but however we have highlited the actual output in captital letters for readers convinience



----------------------------------------------------------------------------------------------------------------------------------------------------------------------





